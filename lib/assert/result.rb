module Assert; end
module Assert::Result

  class Base; end
  class Pass < Base; end
  class Ignore < Base; end
  class Fail < Base; end
  class Error < Base; end
  class Skip < Base; end

  def self.types
    { :pass => Pass,
      :fail => Fail,
      :ignore => Ignore,
      :skip => Skip,
      :error => Error
    }
  end

  class Base

    def self.type; :unknown; end
    def self.name; '';       end

    attr_reader :test, :data

    def initialize(test, message, bt)
      @test = test

      backtrace = Backtrace.new(bt)
      @data = Data.new({
        :type      => self.class.type,
        :name      => self.class.name,
        :test_name => @test.name,
        :message   => message,
        :backtrace => backtrace,
        :trace     => build_trace(backtrace)
      })
    end

    def type;      self.data.type;      end
    def name;      self.data.name;      end
    def test_name; self.data.test_name; end
    def message;   self.data.message;   end
    def backtrace; self.data.backtrace; end
    def trace;     self.data.trace;     end
    def to_sym;    self.data.to_sym;    end
    def to_s;      self.data.to_s;      end

    Assert::Result.types.keys.each do |type|
      define_method("#{type}?"){ self.data.send("#{type}?") }
    end

    # chose to implement this way instead of using an `attr_writer` to be
    # consistant with how you override exception backtraces.
    def set_backtrace(bt)
      self.data.backtrace = Backtrace.new(bt)
      self.data.trace     = build_trace(self.data.backtrace)
    end

    def ==(other_result)
      self.type == other_result.type && self.message == other_result.message
    end

    def inspect
      "#<#{self.class}:#{'0x0%x' % (object_id << 1)} @message=#{self.message.inspect}>"
    end

    private

    # by default, a result's trace is the first line of its filtered backtrace
    def build_trace(backtrace); backtrace.filtered.first.to_s; end

  end

  class Pass < Base

    def self.type; :pass;  end
    def self.name; 'Pass'; end

  end

  class Ignore < Base

    def self.type; :ignore;  end
    def self.name; 'Ignore'; end

  end

  # raised by the 'fail' context helper to break test execution
  TestFailure = Class.new(RuntimeError)

  class Fail < Base

    def self.type; :fail;  end
    def self.name; 'Fail'; end

    # fail results can be generated manually or by raising Assert::Result::TestFailure
    def initialize(test, message_or_exception, bt = nil)
      if message_or_exception.kind_of?(TestFailure)
        super(test, message_or_exception.message, message_or_exception.backtrace)
      elsif message_or_exception.kind_of?(Exception)
        raise ArgumentError, "generate fail results by raising Assert::Result::TestFailure"
      else
        super(test, message_or_exception, bt)
      end
    end

  end

  # raised by the 'skip' context helper to break test execution
  TestSkipped = Class.new(RuntimeError)

  class Skip < Base

    def self.type; :skip;  end
    def self.name; 'Skip'; end

    # skip results are generated by raising Assert::Result::TestSkipped
    def initialize(test, exception)
      if exception.kind_of?(TestSkipped)
        super(test, exception.message, exception.backtrace)
      else
        raise ArgumentError, "generate skip results by raising Assert::Result::TestSkipped"
      end
    end

  end

  class Error < Base

    def self.type; :error;  end
    def self.name; 'Error'; end

    # error results are generated by raising exceptions in tests
    def initialize(test, exception)
      if exception.kind_of?(Exception)
        super(test, "#{exception.message} (#{exception.class.name})", exception.backtrace)
      else
        raise ArgumentError, "generate error results by raising an exception"
      end
    end

    private

    # override of the base, always show the full unfiltered backtrace for errors
    def build_trace(backtrace); backtrace.to_s; end

  end

  class Data

    attr_accessor :type, :name, :test_name, :message, :backtrace, :trace

    def initialize(data = nil)
      data ||= {}

      @type      = (data[:type]      || :unknown).to_sym
      @name      = data[:name]       || ''
      @test_name = data[:test_name]  || ''
      @message   = data[:message]    || ''
      @backtrace = data[:backtrace]  || []
      @trace     = data[:trace]      || ''
    end

    def to_sym; self.type; end

    def to_s
      [ "#{self.name.upcase}: #{self.test_name}",
        self.message,
        self.trace
      ].reject(&:empty?).join("\n")
    end

    Assert::Result.types.keys.each do |type|
      define_method("#{type}?"){ self.type == type }
    end

  end

  class Backtrace < ::Array

    def initialize(value = nil)
      super([*(value || "No backtrace")])
    end

    def to_s; self.join("\n"); end

    def filtered
      self.class.new(self.reject { |line| filter_out?(line) })
    end

    protected

    # filter a line out if it's an assert lib/bin line
    def filter_out?(line)
      # './lib' in project dir, or '/usr/local/blahblah' if installed
      assert_lib_path = File.expand_path('../..', __FILE__)
      assert_bin_regex = /bin\/assert\:/
      line.rindex(assert_lib_path, 0) || line =~ assert_bin_regex
    end

  end

end
